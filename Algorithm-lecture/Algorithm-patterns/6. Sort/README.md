## 6. Sort

: 모여있는 요소들을 재배치하는 과정.  
특정 상황에 따라 사용하는 정렬 방법이 다르다.

### 내장 메서드 sort()

- 유니코드 값을 기본으로 정렬
- 비교 기준인 compatator 함수를 지정할 수 있다.
  - 음수 값을 리턴하면, a 다음에 b
  - 양수 값을 리턴하면, b 다음에 a
  - 0일 경우, 순서 그대로

## 초급 정렬 알고리즘

### 1) Bubble sort

- 한 번에 하나씩 더 큰 값에 대해 버블을 타고 올라가도록 하는 알고리즘.
- 바로 옆의 원소와 비교해서 크기 비교 후, 본인이 더 크면 자리를 바꾼다. (오름차순 기준)
- Best: 거의 정렬되어 있는 배열 O(n)
- Worst: O(n^2)

#### pseudocode

- i라는 변수를 가지고, 배열의 맨 뒤에서 앞으로 루프를 건다. (정렬하는 공간을 줄여나가는 의미)
- 바깥쪽 루프 안에 j라는 변수를 가지고, 앞에서부터 i-1까지 루프를 건다.
- arr[j] > arr[j+1]이면, 자리를 바꿔준다.
- 루프가 끝나면 정렬된 배열을 리턴.
- 이미 정렬된 원소들을 다시 비교하지 않도록, 체크하는 단계 추가.

### 2) Selection sort

- 작은 값을 하나씩 자리에 정렬시키는 알고리즘.
- 가장 작은 값을 찾아 맨 앞에 두고 쌓아가는 방식.
- 배열 정렬도와 상관없이, 매번 순회하며 최소값을 찾아야 하므로 항상 O(n^2)의 시간 복잡도를 가짐.

#### pseudocode

- 최소값을 저장할 변수 저장 (초기값은 첫번째 원소)
- 앞으로 가면서 최소값과 다음 요소 비교
- 그 다음 요소가 더 작으면 최소값을 변경 (인덱스를 저장)
- 한바퀴 돌면, 최소값을 맨 앞으로 보내준다 (swap)
- 다음 루프는 정렬된 이후 요소부터 시작한다 (창문 줄여나가기)

### 3) Insertion sort

- 각 원소를 보면서 이미 정렬되어 있는 곳에서 어디로 가야하는지 찾고 거기로 보낸다.
- Best: 모든 원소가 정렬되어 있을 때 O(n)
- Worst: 모든 원소가 역순일 때 O(n^2)
- 숫자 데이터가 실시간으로 들어오는 경우, 삽입정렬을 사용하는 것이 좋다.

#### Pseudocode

- 배열의 두 번째 원소를 선택해 바로 앞의 원소와 크기 비교
- 정렬된 배열을 순회하며 그 다음 원소가 정확한 자리에 있는지 확인
- 전체 정렬될 때까지 반복

#### Big O of sorting algorithms

| Algorithm      | best   | average | worst  | space <br />complexity |
| -------------- | ------ | ------- | ------ | ---------------------- |
| bubble sort    | O(n)   | O(n^2)  | O(n^2) | O(1)                   |
| insertion sort | O(n)   | O(n^2)  | O(n^2) | O(1)                   |
| selection sort | O(n^2) | O(n^2)  | O(n^2) | O(1)                   |

## 중급 정렬 알고리즘

- 초급 정렬 알고리즘은 배열의 길이가 길어질수록 시간이 오래걸린다.
- 10000개의 원소를 가진 배열일 때, 초급과 중급 정렬은 약 20초 차이가 난다.
- 시간 복잡도가 O(n^2)에서 O(n log n)으로 향상

### 4) Merge sort

- 더 큰 배열을 쪼개서, 더 작은 배열들을 정렬해 나간다 (분할 정복)
- 배열에 원소가 없거나, 하나만 남을 때까지 반복해 분할
- 원소 비교 후, 배열 병합
- 입력값에 상관없이 모두 O(n log n)의 시간복잡도를 가짐
  - 배열을 분할할 때, O(log n)
  - 배열을 병합할 때, O(n)
- 공간복잡도는 O(n)

#### Merging arrays

: **정렬된 배열 두 개를 합치는 방법**

- 두 개의 정렬된 배열을 병합하여 정렬하는 함수 만들기
- 모든 것이 정렬된 새 배열을 만들기 위해 헬퍼 함수 만들기
  - 두 개의 배열에 있는 모든 원소를 포함해야 함
  - 시간/공간 복잡도 모두 O(n + m)

#### Merging arrays Pseudocode

- 두 개의 입력값이 들어가는 함수를 정의하고, 최종 출력할 배열을 만든다.
- 입력된 배열 각각의 가장 작은 값에서 시작
- 두 개의 포인터와 while문을 사용
- i, j가 각각의 배열 끝에 도달하지 못했다면, 첫 번째 배열의 첫 번째 원소를 취해서 두 번째 배열의 첫 번째 원소와 비교
  - 첫 번째 원소가 더 작다면, 해당 값을 출력용 배열에 넣고 첫 번째 배열의 다음 원소로 넘어간다.
  - 두 번째 원소가 더 작다면, 해당 값을 츨력용 배열에 넣고 두 번째 배열의 다음 원소로 넘어간다.
  - 한 배열에 남은 값이 없으면, 다른 배열의 남은 값들을 그대로 넣기

#### Merge sort Pseudocode

- 목표) 빈 배열 혹은 하나의 원소를 가질 때까지 배열을 반으로 분할
  - `Array.slice`를 재귀적으로 사용해 배열 분할
  - 기반 조건: 배열의 길이가 1보다 작거나 같다
- 작은 배열들을 초기 배열의 길이와 같아질 때까지 merge 함수를 사용해 병합

### 5) Quick sort

- 배열이 0이나 1개의 원소를 가지면 각자 정렬된 배열이 된다는 점 이용
- pivot이라는 기준점을 이용하여 해당 숫자보다 작은 숫자들은 왼쪽에, 큰 숫자들은 오른쪽에 두기
- 왼쪽과 오른쪽에 대해 같은 일을 반복
- 시간 복잡도
  - best case) O(nlogn)
  - worst case) 데이터가 이미 정렬되어 있을 경우 O(N^2)

#### Pivot helper

- **배열을 입력**하면, 원소 하나를 기준점으로 지정하고, 배열에 있는 원소를 재배치하는 역할
- pivot 보다 작은 값들을 왼쪽으로, 큰 값들을 오른쪽으로 옮기기 (각 왼/오 배열의 정렬여부는 따지지 않음)
- 새로운 배열을 만들지 않아야 하며, **pivot의 새 인덱스를 출력**해야 함

#### Picking a pivot

- 퀵 정렬의 실행 시간은 어디서 기준점을 뽑느냐에 따라 달라질 수 있다.
- 이상적으로는 pivot이 정중앙일 경우 효율적이나 여기서는 처음 값을 pivot으로 잡기

#### Pivot Pseudocode

- pivot이라는 함수 만들기: 배열, 시작 인덱스, 종료 인덱스라는 세 개의 인수 입력
- 현재 **pivot의 인덱스(pivotIndex)**를 변수에 저장
  - pivotIndex는 pivot보다 작은 원소가 몇개인지 카운트하기 위함
  - 마지막에 기준점을 어디로 옮겨야 하는지 추적할 수 있음
- 배열 전체에 루프를 걸어 시작부터 끝까지 가기
  - pivot > 보고있는 원소 => **pivot 인덱스를 표시하는 변수**를 증가시키고(= pivot보다 작은 원소 카운트), 현재 원소를 pivot 인덱스의 원소와 swap(= 작은 원소를 앞으로 땡겨옴).
- 시작했던 pivot과 **pivot 인덱스**에 있는 것을 swap(= pivot이 완전히 제 자리를 찾음).
- **pivot 인덱스** 출력

#### Quicksort Pseudocode

- arr로 pivot helper를 호출
- pivot의 왼/오 sub배열을 가지고 pivot helper를 재귀호출
- base case: sub배열 길이가 2보다 작을 때

### 6) Radix sort

- 비교 알고리즘이 아닌 정수 정렬 알고리즘
- 이진수를 이용 (다른 데이터를 이진형식으로 가져와 사용할 수 있음)
- 숫자 크기에 대한 정보를 '자릿수'로 인코딩한다는 원리를 이용
- 가장 오른쪽 자리의 숫자부터 시작하여 0~9 버킷에 넣어줌
- 0번째부터 9번째 버킷까지 차례대로 숫자를 빼내어 정렬
- 모든 자릿 수를 확인할 때까지 반복

- 시간 복잡도
  - best case) O(nk)
  - worst case) O(nk)
  - n은 배열의 길이, k는 자리수
  - 아주 긴 자리수를 가진 수가 존재한다면 문제가 됨
  - 참고: 컴퓨터 메모리에 수를 저장하는 방식에 대한 제한이 있다면 시간 복잡도는 달라질 수도 있음

#### helpers

#### getDigit(num, place)

- num의 place번째 자리의 수를 리턴

#### digitCount(num)

- num의 digit이 몇 개인지 리턴

#### mostDigits(nums)

- 목록의 숫자들 중, 가장 자릿수가 많은 수가 무엇인지 리턴

#### RadixSot PseudoCode

- 가장 큰 자릿수가 무엇인지 파악
- 해당 자릿수만큼 루프를 돈다 (k = 0 ~ larest number of digits)
  - 0~9 슬롯의 버킷을 생성
  - 알맞은 버킷 슬롯에 k번째 수를 넣는다
  - 기존의 배열을 버킷내부의 값들로 교체한다 (0~9의 순서를 지키면서)
- 배열 리턴
