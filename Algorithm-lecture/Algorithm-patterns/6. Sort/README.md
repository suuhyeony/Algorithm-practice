## 6. Sort

: 모여있는 요소들을 재배치하는 과정.  
특정 상황에 따라 사용하는 정렬 방법이 다르다.

### 내장 메서드 sort()

- 유니코드 값을 기본으로 정렬
- 비교 기준인 compatator 함수를 지정할 수 있다.
  - 음수 값을 리턴하면, a 다음에 b
  - 양수 값을 리턴하면, b 다음에 a
  - 0일 경우, 순서 그대로

## 초급 정렬 알고리즘

### 1) Bubble sort

- 한 번에 하나씩 더 큰 값에 대해 버블을 타고 올라가도록 하는 알고리즘.
- 바로 옆의 원소와 비교해서 크기 비교 후, 본인이 더 크면 자리를 바꾼다. (오름차순 기준)
- Best: 거의 정렬되어 있는 배열 O(n)
- Worst: O(n^2)

#### pseudocode

- i라는 변수를 가지고, 배열의 맨 뒤에서 앞으로 루프를 건다. (정렬하는 공간을 줄여나가는 의미)
- 바깥쪽 루프 안에 j라는 변수를 가지고, 앞에서부터 i-1까지 루프를 건다.
- arr[j] > arr[j+1]이면, 자리를 바꿔준다.
- 루프가 끝나면 정렬된 배열을 리턴.
- 이미 정렬된 원소들을 다시 비교하지 않도록, 체크하는 단계 추가.

### 2) Selection sort

- 작은 값을 하나씩 자리에 정렬시키는 알고리즘.
- 가장 작은 값을 찾아 맨 앞에 두고 쌓아가는 방식.
- 배열 정렬도와 상관없이, 매번 순회하며 최소값을 찾아야 하므로 항상 O(n^2)의 시간 복잡도를 가짐.

#### pseudocode

- 최소값을 저장할 변수 저장 (초기값은 첫번째 원소)
- 앞으로 가면서 최소값과 다음 요소 비교
- 그 다음 요소가 더 작으면 최소값을 변경 (인덱스를 저장)
- 한바퀴 돌면, 최소값을 맨 앞으로 보내준다 (swap)
- 다음 루프는 정렬된 이후 요소부터 시작한다 (창문 줄여나가기)

### 3) Insertion sort

- 각 원소를 보면서 이미 정렬되어 있는 곳에서 어디로 가야하는지 찾고 거기로 보낸다.
- Best: 모든 원소가 정렬되어 있을 때 O(n)
- Worst: 모든 원소가 역순일 때 O(n^2)
- 숫자 데이터가 실시간으로 들어오는 경우, 삽입정렬을 사용하는 것이 좋다.

#### Pseudocode

- 배열의 두 번째 원소를 선택해 바로 앞의 원소와 크기 비교
- 정렬된 배열을 순회하며 그 다음 원소가 정확한 자리에 있는지 확인
- 전체 정렬될 때까지 반복

#### Big O of sorting algorithms

| Algorithm      | best   | average | worst  | space <br />complexity |
| -------------- | ------ | ------- | ------ | ---------------------- |
| bubble sort    | O(n)   | O(n^2)  | O(n^2) | O(1)                   |
| insertion sort | O(n)   | O(n^2)  | O(n^2) | O(1)                   |
| selection sort | O(n^2) | O(n^2)  | O(n^2) | O(1)                   |

## 중급 정렬 알고리즘

- 초급 정렬 알고리즘은 배열의 길이가 길어질수록 시간이 오래걸린다.
- 10000개의 원소를 가진 배열일 때, 초급과 중급 정렬은 약 20초 차이가 난다.
- 시간 복잡도가 O(n^2)에서 O(n log n)으로 향상

### 4) Merge sort

- 더 큰 배열을 쪼개서, 더 작은 배열들을 정렬해 나간다 (분할 정복)
- 배열에 원소가 없거나, 하나만 남을 때까지 반복해 분할
- 원소 비교 후, 배열 병합
- 입력값에 상관없이 모두 O(n log n)의 시간복잡도를 가짐
  - 배열을 분할할 때, O(log n)
  - 배열을 병합할 때, O(n)
- 공간복잡도는 O(n)

#### Merging arrays

: **정렬된 배열 두 개를 합치는 방법**

- 두 개의 정렬된 배열을 병합하여 정렬하는 함수 만들기
- 모든 것이 정렬된 새 배열을 만들기 위해 헬퍼 함수 만들기
  - 두 개의 배열에 있는 모든 원소를 포함해야 함
  - 시간/공간 복잡도 모두 O(n + m)

#### Merging arrays Pseudocode

- 두 개의 입력값이 들어가는 함수를 정의하고, 최종 출력할 배열을 만든다.
- 입력된 배열 각각의 가장 작은 값에서 시작
- 두 개의 포인터와 while문을 사용
- i, j가 각각의 배열 끝에 도달하지 못했다면, 첫 번째 배열의 첫 번째 원소를 취해서 두 번째 배열의 첫 번째 원소와 비교
  - 첫 번째 원소가 더 작다면, 해당 값을 출력용 배열에 넣고 첫 번째 배열의 다음 원소로 넘어간다.
  - 두 번째 원소가 더 작다면, 해당 값을 츨력용 배열에 넣고 두 번째 배열의 다음 원소로 넘어간다.
  - 한 배열에 남은 값이 없으면, 다른 배열의 남은 값들을 그대로 넣기

#### Merge sort Pseudocode

- 목표) 빈 배열 혹은 하나의 원소를 가질 때까지 배열을 반으로 분할
  - `Array.slice`를 재귀적으로 사용해 배열 분할
  - 기반 조건: 배열의 길이가 1보다 작거나 같다
- 작은 배열들을 초기 배열의 길이와 같아질 때까지 merge 함수를 사용해 병합
