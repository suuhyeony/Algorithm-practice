## 1. Big O Notation

#### 빅오 표기법이 필요한 이유

: "서로 다른 접근 법일 때, 어떤 방법이 좋은가?"에 대해 알 수 있어야 한다. 즉, 빅오 표기법으로 그 정도를 알 수 있는데, 성능을 수치로 비교 가능하여 비효율적인 부분을 찾아내는데 도움을 준다. 또한, 작성한 코드에 대해 제대로 말할 수 있다.

#### 코드 타이밍

: 얼마나 빠르냐에 포커스를 맞춰보자.  
`performance.now()`으로 계산해볼 수도 있으나, 이 방법이 가장 정확한 측정 방법은 아니다. (The Problem with Time) 기계 장치의 성능에 따라 달라질 수도 있고, 같은 기계라도 시간이 다르게 측정되어 신뢰할 수 없다. (매우 빠른 알고리즘이라면 시간 측정 함수로는 도움되지 않을 것이다.)

#### 표현법

: 입력값과 실행시간의 관계 묘사. `O(f(n))`

- **예시**
  - f(n) = n
  - f(n) = n^2
  - f(n) = 1
- 사칙연산 / 변수할당 / 인덱스 활용은 상수
- N이 커짐에 따라 루프의 길이가 늘어남
- 1 < log n < n < n log n < n^2
- 눈대중 법칙  
  2n 은 n과 같이 보고, O(n)으로 계산. (큰 그림으로 생각하여 상수는 중요하지 않음)

#### 시간복잡도

: 문제를 해결하는데 얼마나 빠른 시간이 걸리는가?  
초 단위의 시간을 세지 않고, **컴퓨터의 단순 동작 횟수**를 센다. (시간은 언제나 동작의 횟수에 따라 결정되기 때문)

#### 공간복잡도

: 입력값이 증가함에 따라 메모리 공간을 얼마나 차지하는가? (요즘에는 성능이 많이 좋아져서 시간복잡도가 더 중요하다)  
보조 공간(알고리즘이 실행되는 동안 사용하는 임시공간)을 다룬다.  
(ex. 재귀함수는 재귀호출을 몇 번이나 하는지 등이 공간복잡도에 영향을 미침)

## 2. 배열과 오브젝트의 성능 평가

#### 1) 객체의 빅오

- 객체: 순서가 배정되지 않은 키-값 순서쌍
- 빠른 접근 및 삽입/제거에 간편하다. (순서가 없기에 상수 값의 시간을 가짐)
  - .hasOwnProperty() <-- O(1)
- 탐색만 O(n)의 시간을 가짐. (키에 접근하지 않고, 특정 정보가 값에 있는지 확인할 때)
  - Object.keys() <-- O(n)
  - Object.entries() <-- O(n)

#### 2) 배열의 빅오

- 그 자체로 순서가 존재. (순서가 필요할 때 유용)
- 인덱스를 가짐. (순서를 위해)
- 성능을 최적화하려면 잘 사용하지 않음 (소요가 많음)
  - 배열의 시작부분에 원소를 추가하면 비용이 많이 든다.
- 단일연결/이중연결 리스트를 사용하기도 함

- 접근 시, 몇번째 요소인지만 따지기 때문에 O(1) (배열의 길이와 상관없이 유효 인덱스에 한해)
- 추가 / 삭제 시
  - 맨 뒤에 문자열 추가/제거 시: O(1)
  - 처음에 문자열 삽입/제거 시: O(n) (모든 요소에 새로운 인덱스를 부여해야하기 때문. 되도록 피하자)
- 탐색 시, O(n)

#### +)내장배열 메서드와 성능

- push/pop : O(1)
- shift/unshift : O(n)
- concat / slice / splice : O(n)
- forEach / map / filter / reduce.. : O(n) (루프 돌며 뭔갈 하니까)
- sort : O(nlogn)

## 3. 문제해결 접근법

#### steps

1. 문제 이해하기

   1. 스스로 질문하기. 다른 말로 문제를 바꿔서 설명할 수 있는가?
   2. input은 무엇인가?
   3. output은 무엇인가?
   4. 입력값에 의해 출력값을 알아낼 수 있나?
   5. 데이터의 중요한 부분을 뭐라고 불러야할지?

2. 예시 찾기

   1. 간단한 예시들의 입/출력값 적기
   2. 좀 더 복잡한 예시 찾기
   3. edge case 탐색 (빈값 등..)

3. 세부 분석 (break it down. 쪼개기) <-- 시간이 부족하거나, 끝마치지 못했더라도 내가 무엇을 할 수 있었는지를 보여줌.
   ex)

   1. 객체 만들기
   2. 스트링에 루프를 걸기 (객체에 키가 있다면 카운트 +1, 없다면 키 추가 및 카운트 1)
   3. 리턴하기

4. solve / simplify

   1. (위에서 쪼갠 것에 대해) 문제를 풀 수 있다면 풀고, 풀 수 없다면 더 간단한 문제를 풀기.

5. look back & refactor

   - 다른 방법이 있는가?
   - 잊은 것은 없나?
   - 직관적인가? 한눈에 알아볼 수 있는가?
   - 과거에 비슷한 문제를 푼 적이 있는가?
   - 더 성능이 좋은 코드는 없을까?
   - 다른 사람들의 코드는?
