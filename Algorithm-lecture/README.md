## 1. Big O Notation

#### 빅오 표기법이 필요한 이유

: "서로 다른 접근 법일 때, 어떤 방법이 좋은가?"에 대해 알 수 있어야 한다. 즉, 빅오 표기법으로 그 정도를 알 수 있는데, 성능을 수치로 비교 가능하여 비효율적인 부분을 찾아내는데 도움을 준다. 또한, 작성한 코드에 대해 제대로 말할 수 있다.

#### 코드 타이밍

: 얼마나 빠르냐에 포커스를 맞춰보자.  
`performance.now()`으로 계산해볼 수도 있으나, 이 방법이 가장 정확한 측정 방법은 아니다. (The Problem with Time) 기계 장치의 성능에 따라 달라질 수도 있고, 같은 기계라도 시간이 다르게 측정되어 신뢰할 수 없다. (매우 빠른 알고리즘이라면 시간 측정 함수로는 도움되지 않을 것이다.)

#### 표현법

: 입력값과 실행시간의 관계 묘사. `O(f(n))`

- **예시**
  - f(n) = n
  - f(n) = n^2
  - f(n) = 1
- 사칙연산 / 변수할당 / 인덱스 활용은 상수
- N이 커짐에 따라 루프의 길이가 늘어남
- 1 < log n < n < n log n < n^2
- 눈대중 법칙  
  2n 은 n과 같이 보고, O(n)으로 계산. (큰 그림으로 생각하여 상수는 중요하지 않음)

#### 시간복잡도

: 문제를 해결하는데 얼마나 빠른 시간이 걸리는가?  
초 단위의 시간을 세지 않고, **컴퓨터의 단순 동작 횟수**를 센다. (시간은 언제나 동작의 횟수에 따라 결정되기 때문)

#### 공간복잡도

: 입력값이 증가함에 따라 메모리 공간을 얼마나 차지하는가? (요즘에는 성능이 많이 좋아져서 시간복잡도가 더 중요하다)  
보조 공간(알고리즘이 실행되는 동안 사용하는 임시공간)을 다룬다.  
(ex. 재귀함수는 재귀호출을 몇 번이나 하는지 등이 공간복잡도에 영향을 미침)
